{
  "00 - lib.rs": {
    "prefix": "0 lib",
    "body": [
      "#[proc_macro_derive(Data,)]",
      "pub fn data_macro_derive(input: proc_macro::TokenStream) -> proc_macro::TokenStream {",
      "  let input = syn::parse_macro_input!(input as syn::DeriveInput);",
      "",
      "  #[cfg(feature = \"debug\")]",
      "  eprintln!(\"{:#?}\", input);",
      "",
      "  let output = data_macro_derive_impl(input);",
      "",
      "  #[cfg(feature = \"debug\")]",
      "  eprintln!(\"{}\", output);",
      "",
      "  output.into()",
      "}",
      "",
      "/// Génère le flux de token de manière testable",
      "/// car indépendant de proc_macro !",
      "fn data_macro_derive_impl(input: syn::DeriveInput) -> proc_macro2::TokenStream {",
      "  quote::quote!()",
      "}",
      "",
    ],
    "scope": "rust",
  },
  "01a - Blueprint - Default - Named": {
    "prefix": "1a blueprint default named",
    "body": [
      "// Input",
      "struct Named {",
      "  string: String,",
      "  number: usize,",
      "  boolean: bool,",
      "}",
      "",
      "// Output",
      "impl ::std::default::Default for Named {",
      "  fn default() -> Self {",
      "    Self {",
      "      string: ::std::default::Default::default(),",
      "      number: ::std::default::Default::default(),",
      "      boolean: ::std::default::Default::default(),",
      "    }",
      "  }",
      "}",
      "",
      "// Test",
      "mod tests {",
      "  use super::*;",
      "",
      "  #[test]",
      "  fn named_impl_default() {",
      "    let default = Named::default();",
      "",
      "    assert_eq!(String::default(), default.string, \"string\");",
      "    assert_eq!(usize::default(), default.number, \"number\");",
      "    assert_eq!(bool::default(), default.boolean, \"boolean\");",
      "  }",
      "}",
      "",
    ],
    "scope": "rust",
  },
  "01b - Blueprint - Default - Tuple": {
    "prefix": "1b blueprint default tuple",
    "body": [
      "// Input",
      "struct Tuple(",
      "  String,",
      "  usize,",
      "  bool,",
      ");",
      "",
      "// Output",
      "impl ::std::default::Default for Tuple {",
      "  fn default() -> Self {",
      "    Self(",
      "      ::std::default::Default::default(),",
      "      ::std::default::Default::default(),",
      "      ::std::default::Default::default(),",
      "    )",
      "  }",
      "}",
      "",
      "// Test",
      "mod tests {",
      "  use super::*;",
      "",
      "  #[test]",
      "  fn tuple_impl_default() {",
      "    let default = Tuple::default();",
      "",
      "    assert_eq!(String::default(), default.0, \"0\");",
      "    assert_eq!(usize::default(), default.1, \"1\");",
      "    assert_eq!(bool::default(), default.2, \"2\");",
      "  }",
      "}",
      "",
    ],
    "scope": "rust",
  },
  "02a - impl derive": {
    "prefix": "2a impl derive",
    "body": [
      "fn data_macro_derive_impl(input: syn::DeriveInput) -> proc_macro2::TokenStream {",
      "  let ident = &input.ident;",
      "  quote::quote! {",
      "    impl ::std::default::Default for #ident {",
      "      fn default() -> Self {",
      "        Self",
      "      }",
      "    }",
      "  }",
      "}",
    ],
    "scope": "rust",
  },
  "02b - impl data": {
    "prefix": "2b impl fields",
    "body": [
      "let fields = match input.data {",
      "  syn::Data::Struct(ref data) => data.fields.iter().collect::<Vec<_>>(),",
      "  syn::Data::Enum(_) => panic!(\"enum are not supported!\"),",
      "  syn::Data::Union(_) => panic!(\"union are not supported!\"),",
      "};",
      "let default_fields: proc_macro2::TokenStream = fields",
      "    .iter()",
      "    .map(|field| {",
      "      let ident = field.ident.as_ref().unwrap();",
      "      quote::quote! {",
      "        #ident: ::std::default::Default::default(),",
      "      }",
      "    })",
      "    .collect();",
    ],
    "scope": "rust",
  },
  "02c - impl tuple": {
    "prefix": "2c impl tuple",
    "body": [
      "let prefix = if let Some(ref ident) = field.ident {",
      "  quote::quote!(#ident:)",
      "} else {",
      "  quote::quote!()",
      "};",
      "quote::quote! {",
      "  #prefix ::std::default::Default::default(),",
      "}",
    ],
    "scope": "rust",
  },
  "02d - impl delimiter": {
    "prefix": "2d impl delimiter",
    "body": [
      "(",
      "  data.fields.iter().collect::<Vec<_>>(),",
      "  match data.fields {",
      "    syn::Fields::Named(_) => proc_macro2::Delimiter::Brace,",
      "    syn::Fields::Unnamed(_) => proc_macro2::Delimiter::Parenthesis,",
      "    syn::Fields::Unit => proc_macro2::Delimiter::None,",
      "  },",
      ")",
    ],
    "scope": "rust",
  },
  "03a - model": {
    "prefix": "3a model",
    "body": [
      "pub struct Data {",
      "  pub ident: proc_macro2::Ident,",
      "  pub fields: Fields,",
      "}",
      "",
      "pub struct Fields {",
      "    pub delimiter: proc_macro2::Delimiter,",
      "    pub content: Vec<Field>,",
      "}",
      "",
      "pub struct Field {",
      "    pub ident: Option<proc_macro2::Ident>,",
      "}",
      "",
    ]
  },
  "03b - parser": {
    "prefix": "3b parser",
    "body": [
      "use crate::model;",
      "",
      "pub fn parse(input: syn::DeriveInput) -> model::Data {",
      "    let ident = input.ident.clone();",
      "    let (fields, delimiter) = match input.data {",
      "        syn::Data::Struct(ref data) => (",
      "            data.fields.iter().collect::<Vec<_>>(),",
      "            match data.fields {",
      "                syn::Fields::Named(_) => proc_macro2::Delimiter::Brace,",
      "                syn::Fields::Unnamed(_) => proc_macro2::Delimiter::Parenthesis,",
      "                syn::Fields::Unit => proc_macro2::Delimiter::None,",
      "            },",
      "        ),",
      "        syn::Data::Enum(_) => panic!(\"enum are not supported!\"),",
      "        syn::Data::Union(_) => panic!(\"union are not supported!\"),",
      "    };",
      "    let fields = model::Fields {",
      "        delimiter,",
      "        content: fields",
      "            .into_iter()",
      "            .map(|field| {",
      "                let ident = field.ident.clone();",
      "                model::Field {",
      "                    ident,",
      "                }",
      "            })",
      "            .collect()",
      "    };",
      "    model::Data {",
      "        ident,",
      "        fields,",
      "    }",
      "}",
      "",
    ],
    "scope": "rust",
  },
  "03c - generator": {
    "prefix": "3c generator",
    "body": [
      "use crate::model;",
      "",
      "pub fn generate(data: model::Data) -> proc_macro2::TokenStream {",
      "    let ident = data.ident;",
      "    let default_fields: proc_macro2::TokenStream = data.fields.content",
      "        .iter()",
      "        .map(|field| {",
      "            let prefix = if let Some(ref ident) = field.ident {",
      "                quote::quote!(#ident:)",
      "            } else {",
      "                quote::quote!()",
      "            };",
      "            quote::quote! {",
      "                #prefix ::std::default::Default::default(),",
      "            }",
      "        })",
      "        .collect();",
      "    let field_group = proc_macro2::Group::new(data.fields.delimiter, default_fields);",
      "    quote::quote! {",
      "        impl ::std::default::Default for #ident {",
      "            fn default() -> Self {",
      "                Self #field_group",
      "            }",
      "        }",
      "    }",
      "}",
      "",
    ],
    "scope": "rust",
  },
  "03d - derive": {
    "prefix": "3d derive",
    "body": [
      "fn data_macro_derive_impl(input: syn::DeriveInput) -> proc_macro2::TokenStream {",
      "  let data = parser::parse(input);",
      "  generator::generate(data)",
      "}",
    ],
    "scope": "rust",
  },
}
